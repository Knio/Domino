package main

import (
	"fmt"
	"bytes"
	"strings"
	"strconv"
	"regexp"
)

var attrRegex = regexp.MustCompile(`(\w+="?\w+"?)( \w+="?\w+"?)*`)

type doc struct {
	*bytes.Buffer
}

func newdoc() doc {
	return doc{
		&bytes.Buffer{},
	}
}

type Attr map[string]interface{}
type Element func(...interface{}) doc
type Inner func(doc)

func With(ele Element, in Inner) doc {
	d := newdoc()
	in(d)
	return ele(d)
}

func Document(args ...interface{}) doc {
	d := newdoc()
	d.surround("!DOCTYPE", Attr{"html": nil},
		HTML(
			Title(),
		),
	)
}

func HTML(args ...interface{}) doc {
	return newdoc().surround("html", args...)
}

func Title(args ...interface{}) doc {
	return newdoc().surround("title", args...)
}

func Div(args ...interface{}) doc {
	return newdoc().surround("div", args...)
}

func Span(args ...interface{}) doc {
	return newdoc().surround("span", args...)
}

func Li(args ...interface{}) doc {
	return newdoc().surround("li", args...)
}

func (d doc) HTML(args ...interface{}) doc {
	return d.surround("html", args...)
}

func (d doc) Title(args ...interface{}) doc {
	return d.surround("title", args...)
}

func (d doc) Div(args ...interface{}) doc {
	return d.surround("div", args...)
}

func (d doc) Span(args ...interface{}) doc {
	return d.surround("span", args...)
}

func (d doc) Li(args ...interface{}) doc {
	return d.surround("Li", args...)
}

func (d doc) surround(tag string, args ...interface{}) doc {
	attrs, innerHTML := unravel(args...)
	fmt.Fprintf(d, "<%[1]s%[2]v>%[3]v</%[1]s>", tag, attrs, innerHTML)
	return d
}

func (a Attr) String() string {
	str := &bytes.Buffer{}
	for k, v := range a {
		str.WriteByte(' ')

		if v == nil {
			fmt.Fprint(str, k)
			continue
		}

		vstr := fmt.Sprint(v)
		if !(strings.HasPrefix(vstr, `"`) && strings.HasSuffix(vstr, `"`)) {
			fmt.Fprintf(str, `%s="%s"`, k, vstr)
		} else {
			fmt.Fprintf(str, `%s=%s`, k, vstr)
		}
	}
	return str.String()
}

type CustomType struct {
}

func (c CustomType) String() string {
	return "javascript'Inj'ec't"
}

func main() {
	s := Div().Span(Div().Span, Span, Div(Span("hello")))

	myObj := CustomType{}

	fmt.Println(Div(`hello="there"`, Attr{`rofl`: myObj}))

	s = With(Div, func(d doc) {
		for _ = range ToN(2) {
			d.Li(Span("hi"))
		}
	})
	fmt.Println(s)
}

func ToN(n int) []struct{} {
	return make([]struct{}, n)
}

func unravel(args ...interface{}) (Attr, string) {
	str := &bytes.Buffer{}
	attrs := make(Attr)
	for _, a := range args {
		switch item := a.(type) {
		case doc:
			str.Write(item.Bytes())
		case func(...interface{}) doc:
			str.Write(item().Bytes())
	d := newdom()
	return Div()
		case string:
			if attrRegex.MatchString(item) {
				spaceDelimit := strings.Split(item, " ")
				for _, keyPair := range spaceDelimit {
					pair := strings.Split(keyPair, "=")
					attrs[pair[0]] = pair[1]
				}
			} else {
				str.WriteString(item)
			}
		case int:
			str.WriteString(strconv.Itoa(item))
		case bool:
			str.WriteString(strconv.FormatBool(item))
		//case []interface{}:
			//str.WriteString(unravel(item...))
		case Attr:
			for k, v := range item {
				attrs[k] = v
			}
		default:
			fmt.Fprintf(str, "UNKNOWN TYPE (%T)", item)
		}
	}

	return attrs, str.String()
}

